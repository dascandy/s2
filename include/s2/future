#pragma once

#include "detail/future_detail.h"

namespace s2 {

class default_executor;
template <typename... Ts>
class promise;

default_executor& get_default_executor();

template <typename T>
class shared_state;

template <typename... Ts>
class future {
public:
  using value_type = detail::future_type<Ts...>;
  constexpr future() noexcept = default;
  future(future&&) noexcept = default;
  future& operator=(future&&) noexcept = default;
  future(const future&) noexcept = default;
  future& operator=(const future&) noexcept = default;

  template <typename... Us>
  future(Us&&... us);
  template <typename Ex, typename C>
  auto then(Ex&& ex, C&& c);
  template <typename C>
  auto then(C&& c) { return (*this).then(get_default_executor(), ::std::forward<decltype(c)>(c)); }
  bool ready() const noexcept;
  bool valid() const noexcept;
  auto get() const;
private:
  future(shared_state<std::tuple<Ts...>>* state) : state(state) {}
  friend class promise<Ts...>;
  shared_state<std::tuple<Ts...>> *state;
};

template <typename... Ts>
class promise {
public:
  promise() noexcept;

  future<Ts...> get_future();
  template <typename... Us>
  void set_value(Us&&... us); 
  void set_exception(std::exception_ptr&& error); 
  template <typename F, typename... Args>
  void run_async(F&& f, Args&&... args);
private:
  using value_type = detail::future_type<Ts...>;
  shared_state<std::tuple<Ts...>> *state;
};

template <typename Executor, typename F, typename... Args>
future<decltype(std::declval<F>()(std::declval<Args>()...))>
async(Executor&& exec, F&& f, Args&&... args);

template <typename F, typename... Args>
future<decltype(std::declval<F>()(std::declval<Args>()...))>
async(F&& f, Args&&... args) { return async(get_default_executor(), ::std::forward<decltype(f)>(f), ::std::forward<decltype(args)>(args)...); }

}

#include "detail/future_impl.h"


