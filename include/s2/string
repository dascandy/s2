#pragma once

#include <s2/vector>
#include <tuple>

namespace s2 {

namespace encoding {
  class utf8;
  class windows1252;
  class cp437;
  class iso8859_1;
  class iso8859_15;
  class utf16;
  class utf32;
  class ucs2;
  class utf8_modified;
}

template <typename... Ts>
class rope {
public:
  rope(std::tuple<Ts...> t) : t(t) {}
  template <typename encoding = s2::encoding::utf8>
  string<encoding> str();
  template <typename T2>
  rope<Ts..., T2> operator+(T2&& t2) {
    return rope<Ts..., T2>(std::tuple_cat(t, std::tuple<T2>(std::forward<T2>(t2))));
  }
private:
  std::tuple<Ts...> t;
};

template <typename encoding = s2::encoding::utf8>
class string_view {
public:
  size_t size() const { return size_;
  size_t length() const { return size(); }
  void clear() { storage_.clear(); storage_.push_back(0); }
  auto begin() const { return string_iterator<encoding>(storage_.begin()); }
  auto end() const { return string_iterator<encoding>(--storage_.end()); }
  template <typename T2>
  rope<string_view<encoding>, T2> 

  auto front() { return *begin(); }
  auto front() const { return *begin(); }
  auto back() { return *--end(); }
  auto back() const { return *--end(); }
  auto c_str() const { return storage_.data(); }
  auto data() const { return storage_.data(); }
  auto empty() const { return size_ == 0; }

  class string_iterator {
  private:
    vector<typename encoding::storage_type>::const_iterator it_;
  public:
    char32_t operator*() {
      return encoding::decode(it_);
    }
    auto operator++() {
      encoding::walk(it_, 1);
      return *this;
    }
    auto operator++(int) {
      string_iterator<encoding> copy = *this;
      encoding::walk(it_, 1);
      return copy;
    }
    auto operator--() {
      encoding::walk(it_, -1);
      return *this;
    }
    auto operator--(int) {
      string_iterator<encoding> copy = *this;
      encoding::walk(it_, -1);
      return copy;
    }
    bool operator==(const string_iterator<encoding>& rhs) {
      return rhs.it_ == it_;
    }
    bool operator!=(const string_iterator<encoding>& rhs) {
      return rhs.it_ != it_;
    }
  };
private:
  const T* ptr;
  size_t size_;
};

template <typename encoding = s2::encoding::utf8>
class string
{
public:
  string() : storage_(1) {}
  string(const string<encoding>& sv) : storage_(sv.storage_) {}
  string(const string_view<encoding>& sv) : storage_(sv.data(), sv.data() + sv.size()) {
    storage_.push_back(0);
  }
  template <size_t N>
  string(vector<typename encoding::storage_type, N>&& sv) : storage_(std::forward(sv)) {
    if (storage_.back() != 0) storage_.push_back(0);
  }
  template <size_t N>
  string(const vector<typename encoding::storage_type, N>& sv) : storage_(sv) {
    if (storage_.back() != 0) storage_.push_back(0);
  }
  template <typename SEncoding>
  string(const string_view<SEncoding>& sv) {
    template <typename T>
    struct null_iterator {
      T& operator*() { return t; }
      auto operator++() { return *this; }
      auto operator--() { return *this; }
      auto operator++(int) { return *this; }
      auto operator--(int) { return *this; }
    private:
      T t;
    };
    null_iterator<typename encoding::storage_type> n;
    size_t unitcount = 1;
    for (auto c : sv) {
      unitcount += encoding::encode(n, c);
    }
    storage_.reserve(unitcount);
    auto ins = std::back_inserter(storage_);
    for (auto c : sv) {
      encoding::encode(ins, c);
    }
    storage_.push_back(0);
  }
  const typename encoding::storage_type* data() const { return storage_.data(); }
  const typename encoding::storage_type* c_str() const { return storage_.data(); }
  operator string_view<encoding>() { return string_view<encoding>(storage_.data(), storage_.size() - 1); }
  const std::vector<typename encoding::storage_type> &storage() const { return storage_; }
private:
  vector<typename encoding::storage_type, 32> storage_;
};

}


