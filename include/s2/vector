#include <iostream>
#include <type_traits>
#include <string>
#include <initializer_list>
#include <assert.h>
#include <new>

namespace s2 {

template<class T, size_t maxsize = 128>
class vector
{
  // properly aligned uninitialized storage for N T's
  static constexpr size_t innerCapacity_ = (maxsize - 2) / sizeof(T);
  union {
    std::aligned_storage_t<innerCapacity_ * sizeof(T), alignof(T)> data_;
    struct {
      std::size_t size_;
      std::size_t capacity_;
      T* ptr_;
    };
  };
  uint8_t innerSize_ = innerCapacity_;
  static_assert(innerCapacity_ < 255, "Cannot make a local storage of larger than 255 local items");
  bool isExternal() { return innerSize_ == 255; }
  T* ptr() {
    return isExternal() ? ptr_ : reinterpret_cast<T*>(&data_);
  }
public:
  // Functions that do something with the internals
  size_t capacity() {
    return isExternal() ? capacity_ : innerCapacity_;
  }
  size_t size() {
    return isExternal() ? size_ : innerCapacity_ - innerSize_;
  }
  void reserve(size_t newCapacity) {
    if (newCapacity <= capacity()) return;
    // TODO: alignment // TODO: exception safety
    T* newPtr = reinterpret_cast<T*>(new unsigned char[sizeof(T) * newCapacity]);
    size_t tsize = size();
    for (size_t n = 0; n < tsize; n++) {
      new (&newPtr[n])T(std::move(ptr()[n]));
      ptr()[n].~T();
    }
    if (isExternal())
      delete [] (reinterpret_cast<unsigned char*>(ptr_));
    ptr_ = newPtr;
    capacity_ = newCapacity;
    size_ = tsize;
    innerSize_ = 255;
  }
  void grow() {
    // holder for grow policy
    if (capacity() == size())
      reserve(2 + capacity() + capacity() / 2);
  }
  void shrink_to_fit() {
    // We can't shrink the internal buffer
    if (!isExternal()) return;
    if (size() < innerCapacity_) {
      // Internalize again
      size_t tsize = size();
      T* tptr = ptr();
      innerSize_ = innerCapacity_ - tsize;
      for (size_t n = 0; n < tsize; n++) {
        new (&ptr()[n])T(std::move(tptr[n]));
        tptr[n].~T();
      }
      delete [] (reinterpret_cast<unsigned char*>(tptr));
    } else if (size_ < 3*(capacity_/4)) {
      // realloc to smaller buffer, but only if there's a 25% or more gain to be had
      T* tptr = ptr();
      T* newPtr = reinterpret_cast<T*>(new unsigned char[sizeof(T) * size_]);
      for (size_t n = 0; n < size_; n++) {
        new (&newPtr[n])T(std::move(tptr[n]));
        tptr[n].~T();
      }
      delete [] (reinterpret_cast<unsigned char*>(tptr));
      ptr_ = newPtr;
      capacity_ = size_;
    }
  }
  void push_back(const T& value) {
    grow();
    new (&ptr()[size()])T(value);
    if (isExternal()) size_++; else innerSize_--;
  }
  void push_back(T&& value) {
    grow();
    new (&ptr()[size()])T(std::forward<decltype(value)>(value));
    if (isExternal()) size_++; else innerSize_--;
  }
  T pop_back() {
    assert(!empty());
    struct do_at_function_exit {
      do_at_function_exit(vector<T>* v) : v(v) {}
      ~do_at_function_exit() {
        if (disable) return;
        v->ptr()[v->size() - 1].~T();
        if (v->isExternal()) v->size_--; else v->innerSize_++;
      }
      vector<T>* v;
      bool disable = false;
    } _inst(this);
    try {
      return std::move(ptr()[size() - 1]);
    } catch (...) {
      _inst.disable = true;
      throw;
    }
  }

  // Functions that just rely on the functions above to do what they do
  constexpr vector() noexcept {}
  explicit vector(size_t count) {
    while (count--) push_back(T());
  }
  vector(size_t count, const T& value) {
    while (count--) push_back(value);
  }
  template <typename IT>
  vector(IT first, IT last) {
    assign(first, last);
  }
  vector(vector<T>&& other) noexcept(std::is_nothrow_move_constructible<T>::value) {
    if (other.isExternal()) {
      innerSize_ = 255;
      size_ = other.size_;
      capacity_ = other.capacity_;
      ptr_ = other.ptr_;
    } else {
      for (size_t n = 0; n < other.size(); n++) {
        push_back(std::move(other[n]));
      }
    }
  }
  vector(const vector<T>& other) {
    reserve(other.size());
    assign(other.begin(), other.end());
  }
  vector(std::initializer_list<T> init) {
    assign(init);
  }
  ~vector() {
    resize(0);
    shrink_to_fit();
  }
  void assign(size_t count, const T& value) {
    clear();
    for (size_t n = 0; n < count; n++) push_back(value);
  }
  template <typename IT>
  void assign(IT first, IT last) {
    clear();
    while (first != last) push_back(*first++);
  }
  void assign(std::initializer_list<T> ilist) {
    clear();
    reserve(ilist.size());
    auto it = ilist.begin(), end = ilist.end();
    while (it != end) push_back(*it++);
  }
  void resize(size_t newSize) {
    if (newSize <= size()) {
      while (newSize < size())
        pop_back();
      return;
    }
    while (newSize > size_) {
      push_back(T());
    }
  }
  const T* data() {
    return ptr();
  }
  const T& operator[](size_t index) const noexcept {
    assert(index < size());
    return ptr()[index];
  }
  T& operator[](size_t index) noexcept {
    assert(index < size());
    return ptr()[index];
  }
  const T& at(size_t index) const {
    if (index >= size()) throw std::out_of_range("index out of bounds");
    return ptr()[index];
  }
  T& at(size_t index) {
    if (index >= size()) throw std::out_of_range("index out of bounds");
    return ptr()[index];
  }
  T& front() { 
    assert(!empty());
    return ptr()[0];
  }
  T& back() { 
    assert(!empty());
    return ptr()[size() - 1]; 
  }
  void clear() noexcept { resize(0); }
  bool empty() noexcept { return size() == 0; }
  template<typename ...Args> 
  void emplace_back(Args&&... args) {
    grow();
    new(&ptr()[size()])T(std::forward<Args>(args)...);
    if (isExternal()) size_++; else innerSize_--;
  }
};

}



