#include <iostream>
#include <type_traits>
#include <string>
#include <initializer_list>

namespace s2 {

template<class T, size_t maxsize = 128>
class vector
{
  // properly aligned uninitialized storage for N T's
  static constexpr size_t innerCapacity = (maxsize - 2) / sizeof(T);
  union {
    std::aligned_storage_t<innerCapacity * sizeof(T), alignof(T)> data_;
    struct {
      std::size_t size_;
      std::size_t capacity_;
      T* ptr_;
    };
  };
  uint8_t innerSize_ = innerCapacity_;
  static_assert(innerCapacity_ < 255, "Cannot make a local storage of larger than 255 local items");
  bool isExternal() { return innerSize_ == 255; }
  T* ptr() {
    return isExternal() ? ptr_ : reinterpret_cast<T*>(&data_);
  }
public:
  // Functions that do something with the internals
  size_t capacity() {
    return isExternal() ? capacity_ : innerCapacity_;
  }
  size_t size() {
    return isExternal() ? size_ : innerCapacity_ - innerSize_;
  }
  void reserve(size_t newCapacity) {
    if (newCapacity <= capacity()) return;
    // TODO: alignment // TODO: exception safety
    T* newPtr = reinterpret_cast<T*>(new unsigned char[sizeof(T) * newCapacity]);
    for (size_t n = 0; n < size(); n++) {
      new (&newPtr[n])T(std::move(ptr()[n]));
      ptr()[n]->~T();
    }
    if (isExternal())
      delete [] (reinterpret_cast<unsigned char*>(ptr_));
    ptr_ = newPtr;
    capacity_ = newCapacity;
  }
  void shrink_to_fit() {
    // We can't shrink the internal buffer
    if (!isExternal()) return;
    if (size() < innerCapacity) {
      // Internalize again
      size_t size = size();
      T* ptr = ptr();
      for (size_t n = 0; n < size; n++) {
        new (&data_[n])T(std::move(ptr[n]));
        ptr[n]->~T();
      }
      delete [] (reinterpret_cast<unsigned char*>(ptr));
      innerSize_ = innerCapacity_ - size;
    } else if (size_ < 3*(capacity_/4)) {
      // realloc to smaller buffer, but only if there's a 25% or more gain to be had
      T* ptr = ptr();
      T* newPtr = reinterpret_cast<T*>(new unsigned char[sizeof(T) * size_]);
      for (size_t n = 0; n < size_; n++) {
        new (&newPtr[n])T(std::move(ptr[n]));
        ptr[n]->~T();
      }
      delete [] (reinterpret_cast<unsigned char*>(ptr));
      ptr_ = newPtr;
      capacity_ = size_;
    }
  }
  void push_back(T&& value) {
    reserve(size() + 1);
    new (ptr()[size()])T(std::forward<decltype(value)>(value));
    if (isExternal()) size_++; else innerSize_--;
  }
  T pop_back() {
    assert(!empty());
    struct do_at_function_exit {
      do_at_function_exit(vector<T>* v) : v(v) {}
      ~do_at_function_exit() {
        if (disable) return;
        v->ptr()[v->size() - 1]->~T();
        if (v->isExternal()) v->size_--; else v->innerSize_++;
      }
      vector<T>* v;
      bool disable = false;
    } _inst(this);
    try {
      return std::move(ptr()[size() - 1]);
    } catch (...) {
      _inst.disable = true;
    }
  }

  // Functions that just rely on the functions above to do what they do
  constexpr vector() noexcept {}
  explicit vector(size_t count) {
    while (count--) push_back(T());
  }
  vector(size_t count, const T& value) {
    while (count--) push_back(value);
  }
  template <typename IT>
  vector(IT first, IT last) {
    assign(first, last);
  }
  vector(vector<T>&& other) noexcept(std::is_nothrow_move_constructible_v<T>) {
    if (other.isExternal()) {
      innerSize_ = 255;
      size_ = other.size_;
      capacity_ = other.capacity_;
      ptr_ = other.ptr_;
    } else {
      for (size_t n = 0; n < other.size(); n++) {
        push_back(std::move(other[n]));
      }
    }
  }
  vector(const vector<T>& other) {
    reserve(other.size());
    assign(other.begin(), other.end());
  }
  vector(std::initializer_list<T> init) {
    assign(init);
  }
  ~vector() {
    resize(0);
    shrink_to_fit();
  }
  void assign(size_t count, const T& value) {
    clear();
    for (size_t n = 0; n < count; n++) push_back(value);
  }
  template <typename IT>
  void assign(IT first, IT last) {
    clear();
    while (first != last) push_back(*first++);
  }
  void assign(std::initializer_list<T> ilist) {
    clear();
    reserve(ilist.size());
    auto it = ilist.begin(), end = ilist.end();
    while (it != end) push_back(*it++);
  }
  void resize(size_t newSize) {
    if (newSize <= size_) {
      while (newSize < size_)
        pop_back();
      return;
    }
    while (newSize > size_) {
      push_back(T());
    }
  }
  const T* data() {
    return ptr();
  }
  const T& operator[](size_t index) const noexcept {
    assert(index < size());
    return ptr()[index];
  }
  T& operator[](size_t index) noexcept {
    assert(index < size());
    return ptr()[index];
  }
  const T& at(size_t index) const {
    if (index >= size()) throw std::out_of_range();
    return ptr()[index];
  }
  T& at(size_t index) {
    if (index >= size()) throw std::out_of_range();
    return ptr()[index];
  }
  T& front() { 
    assert(!empty());
    return ptr()[0];
  }
  T& back() { 
    assert(!empty());
    return ptr()[size() - 1]; 
  }
  void clear() noexcept { resize(0); }
  bool empty() noexcept { return size() == 0; }
  template<typename ...Args> void emplace_back(Args&&... args)
  {
    if( m_size >= N ) // possible error handling
      throw std::bad_alloc{};
    new(data+m_size) T(std::forward<Args>(args)...);
    ++m_size;
  }
};

}



