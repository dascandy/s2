#include <iostream>
#include <type_traits>
#include <string>

namespace s2 {

template<class T>
class vector
{
    // properly aligned uninitialized storage for N T's
    static constexpr size_t innerCapacity = sizeof(126) / sizeof(T);   // Make object 128 bytes, or less.
    union {
      std::aligned_storage_t<innerCapacity * sizeof(T), alignof(T)> data_;
      struct {
        std::size_t capacity_;
        T* ptr_;
      };
    };
    uint8_t shortSize_;
    uint8_t isInternal_;

public:
    size_t size() {

    }
    // Create an object in aligned storage
    template<typename ...Args> void emplace_back(Args&&... args)
    {
        if( m_size >= N ) // possible error handling
            throw std::bad_alloc{};
        new(data+m_size) T(std::forward<Args>(args)...);
        ++m_size;
    }

    // Access an object in aligned storage
    const T& operator[](std::size_t pos) const
    {
        return *reinterpret_cast<const T*>(data+pos);
    }

    // Delete objects from aligned storage
    ~vector()
    {
        for(std::size_t pos = 0; pos < m_size; ++pos) {
            reinterpret_cast<T*>(data+pos)->~T();
        }
    }
};

}



